<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<title>Recursiveness - set_trace_func</title>

<!-- Meta -->
<meta name="description" content="Just a random coder writing about technology, web development, and various other geeky topics." />
<meta name="author" content="Jamie Macey">
<link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/index.xml" />

<!-- Favicons -->
<!-- 
<link rel="apple-touch-icon" href="/docs/5.2/assets/img/favicons/apple-touch-icon.png" sizes="180x180">
<link rel="icon" href="/docs/5.2/assets/img/favicons/favicon-32x32.png" sizes="32x32" type="image/png">
<link rel="icon" href="/docs/5.2/assets/img/favicons/favicon-16x16.png" sizes="16x16" type="image/png">
<link rel="manifest" href="/docs/5.2/assets/img/favicons/manifest.json">
<link rel="mask-icon" href="/docs/5.2/assets/img/favicons/safari-pinned-tab.svg" color="#712cf9">
<link rel="icon" href="/docs/5.2/assets/img/favicons/favicon.ico">
-->

<!-- Style -->
<link rel="stylesheet" href="/_bridgetown/static/index.J6BIDSPS.css" />

<!-- Script -->
<!-- <script src="/_bridgetown/static/index.PJZZ2K4I.js" defer></script> -->


    <link type="application/atom+xml" rel="alternate" href="https://blog.tracefunc.com/index.xml" title="set_trace_func" />
  </head>
  <body class="post ">
    <header>
  <nav>
    <ul>
      <li><h1><a href="/">set_trace_func</a></h1></li>
      <!-- The following float right, and are defined right-to-left -->
      <li class="float-right"><a href="/notes/">Notes</a></li>
      <li class="float-right"><a href="/projects/">Projects</a></li>
      <li class="float-right"><a href="/tags/">Tags</a></li>
      <li class="float-right"><a href="/archive/">Archive</a></li>
    </ul>
  </nav>
</header>


    <main>
      <aside>


<div>
  <h4>About</h4>
  <picture class="float-end w-50 rounded-circle">
    <source srcset="/assets/memoji.webp" type="image/webp">
    <source srcset="/assets/memoji.jpeg" type="image/jpeg">
    <img src="/assets/memoji.png" alt="Avatar of Author" loading="lazy" class="w-100">
  </picture>

  <p>Jamie Macey is a senior software engineer with over 15 years experience
            in the Ruby and Rails ecosystems, largely on the back-end.</p>
  <p class="mb-0">Husband, father, gamer, and all-around geek. Ask about my latest
            3d print, or toy software project.</p>
</div>

<div>
  <h4>Elsewhere</h4>
  <ol class="list-unstyled">
    <li>
      <a href="https://github.com/jamie/"">GitHub</a>
    </li>
    <li style="display: none;">
      <a rel="me" href="https://ruby.social/@jamie_ca">Mastodon</a>
    </li>
    <li>
      <a href="/static/jamie-macey/">Resume</a>
    </li>
    <li>
      <a href="https://www.linkedin.com/in/jamiemacey/">Linkedin</a>
    </li>
    <li>
      <a href="mailto:jamie.blog@tracefunc.com">Contact</a>
    </li>
  </ol>
</div>
</aside>

      <section>
  <article>
  <h2><a href="/2006/09/25/recursiveness-html/">Recursiveness</a></h2>
  <blockquote>
    25th Sep 2006
    
      | Tags:
      <a href="/tags/#programming">programming</a> <a href="/tags/#ruby">ruby</a> 
    
  </blockquote>

  
    <p>One of the big things I learned at University was that while “Recursion is a Wonderful Thing” (Thank you, Dr. Roelants), sometimes the performance can really hurt. Those times, it can pay to spend the effort turning that recursive function into a simple loop. Sure, it might not be as clean, or as elegant, or as natural to understand, but we’re looking at performance here, right?</p>

<p>Ryan Davis recently <a href="http://blog.zenspider.com/archives/2006/09/recursive_functions_in_rubyinline.html">posted</a> about using RubyInline to optimize a recursive factorial method. He ended with a caveat that sometimes you need to look at other things than just moving the code into C for speed. His idea was to cache the data as it goes along. There are times when that won’t help you in the log run (for example, generating a stats graph where caching as you draw helps, but the cached values will be stale the next time you need to do it) but changing it around to iterative can sometimes give you a further speedup.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">fib_iter</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">3</span>  
  <span class="n">f</span> <span class="o">=</span> <span class="n">f1</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">(</span><span class="mi">2</span><span class="o">..</span><span class="n">n</span><span class="p">).</span><span class="nf">each</span> <span class="k">do</span>
    <span class="n">f</span><span class="p">,</span> <span class="n">f1</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="o">+</span><span class="n">f1</span><span class="p">),</span> <span class="n">f</span>
  <span class="k">end</span>
  <span class="n">f</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>The benchmarking speaks for itself. (Same parameters as Ryan’s benching, 10,000 runs doing fib(15)):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>                      user     system      total        real
fib-ruby         21.180000   3.640000  24.820000 ( 24.989140)
fib-hash-reset    0.510000   0.070000   0.580000 (  0.609976)
fib-cache-reset   0.510000   0.050000   0.560000 (  0.570715)
fib-iter          0.160000   0.020000   0.180000 (  0.209565)
fib-hash          0.020000   0.000000   0.020000 (  0.034616)
fib-cached        0.020000   0.010000   0.030000 (  0.035222)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Benchmarks for fib-ruby and fib-cached come from Ryan’s post. fib-iter and fib-hash are mine.</p>

<p>The two “-reset” methods are indicative of times when global caching won’t help you, which is still a significant speedup over the uncached versions. (For fib(15), uncached will need ~610 method calls, compared to ~15) The iterative method is about 1/3 their speed, but when you can globally cache you can get huge gains - if I increased the number of runs in the benchmark, the discrepancy between fib-iter and fib-cached would increase even more.</p>

<p>So once again, it seems that there’s a different best solution for two different problems.</p>

<p>And the fib-hash benchmark? It’s not significantly faster than Ryan’s fib-cached method, but it bumps the fib logic from a method that uses a hash into the hash itself. It’s a neat trick I picked up a while ago, but probably too ugly to make significant use of unless your benchmarking tells you otherwise - it’s really hard to read at first glance:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">hashfib</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span>
  <span class="n">h</span> <span class="o">=</span> <span class="no">Hash</span><span class="p">.</span><span class="nf">new</span><span class="p">{</span><span class="o">|</span><span class="n">h</span><span class="p">,</span><span class="n">k</span><span class="o">|</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="p">}</span>
  <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">h</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">h</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<table>
  <tbody>
    <tr>
      <td>The cached version uses @@h instead of h, and</td>
      <td> </td>
      <td>=s it.</td>
    </tr>
  </tbody>
</table>


  
</article>

</section>

<nav aria-label="Pagination">
  <ul>
    
    <li>
      <a href="/2006/09/13/dynamic-activerecord-attributes-html/">
        &laquo; Dynamic ActiveRecord Attributes
      </a>
    </li>
    
    
    <li class="float-right">
      <a href="/2006/12/28/resolutions-html/">
        Resolutions &raquo;
      </a>
    </li>
    
  </ul>
</nav>

    </main>

    <footer>
  <p>Styled with <a href="https://classless.de/">Classless.css</a>.</p>
</footer>


    <script data-goatcounter="https://tracefunc.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script>
  </body>

</html>

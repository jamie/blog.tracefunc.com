<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
  <title>set_trace_func</title>
  <subtitle>blog.tracefunc.com</subtitle>
  <link href="http://blog.tracefunc.com/" rel="self" />
  <link href="http://blog.tracefunc.com/" />
  <updated>2009-12-04T19:43:28-05:00</updated>
  <author>
    <name>Jamie Macey</name>
    <email>jamie.blog@tracefunc.com</email>
  </author>
  <id>http://blog.tracefunc.com/</id>
  
  <entry>
    <title>Jekyll: Custom Liquid Tags</title>
    <link href="http://blog.tracefunc.com/2009/12/02/jekyll-custom-liquid-tags/" />
    <id>tag:blog.tracefunc.com,2009-12-02T00:00:00-05:00:1259973735</id>
    <updated>2009-12-04T19:42:15-05:00</updated>
    <content type="html">&lt;p&gt;The base install of &lt;a href=&quot;http://github.com/mojombo/jekyll&quot;&gt;Jekyll&lt;/a&gt; at the moment doesn't let you run &lt;em&gt;any&lt;/em&gt; arbitrary ruby code. This is so that they can use it for github pages and not need to worry about making a super-secure sandbox just to generate some HTML.&lt;/p&gt;

&lt;p&gt;Unfortunately, that means we're out of luck for creating custom liquid filters. The most annoying deficiency for me is tags. The way the default liquid &lt;code&gt;map&lt;/code&gt; filter works isn't friendly with @site.tags, so to generate my &lt;a href=&quot;/tags/&quot;&gt;Tags&lt;/a&gt; page I had to do some really crazy stuff with &lt;code&gt;capture&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;articles&quot;&amp;gt;
  &amp;lt;table&amp;gt;
    {% for tag_ in @site.tags %}
      {% capture tag %}{{ tag_ | first }}{% endcapture %}
      &amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;{{ tag }}&amp;lt;/th&amp;gt;
          &amp;lt;th&amp;gt;&amp;lt;a name=&quot;{{ tag }}&quot; class=&quot;anchor&quot;&amp;gt;&amp;amp;nbsp;&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;
      {% for post in @site.posts %}
        {% if post.tags contains tag %}
          &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;{{ post.date | date: '%b %e, %Y' }}&amp;lt;/td&amp;gt;
              &amp;lt;td&amp;gt;&amp;lt;a href=&quot;{{ post.url }}&quot;&amp;gt;{{ post.title }}&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
        {% endif %}
      {% endfor %}
    {% endfor %}
  &amp;lt;/table&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fortunately, it wasn't to hard to make a fork, and in &lt;a href=&quot;http://github.com/jamie/jekyll&quot;&gt;my fork&lt;/a&gt; I added a super simple code loading option. Now, I can add a quick extension in &lt;code&gt;_lib/filters.rb&lt;/code&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;module Jekyll
  module Filters
    def keys(input)
      input.keys
    end

    def tagged(input, tag)
      input.select{|post| post.tags.include? tag}
    end
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now &lt;code&gt;tags.html&lt;/code&gt; looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&quot;articles&quot;&amp;gt;
  &amp;lt;table&amp;gt;
    {% for tag in @site.tags|keys|sort %}
      &amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;{{ tag }}&amp;lt;/th&amp;gt;
          &amp;lt;th&amp;gt;&amp;lt;a name=&quot;{{ tag }}&quot; class=&quot;anchor&quot;&amp;gt;&amp;amp;nbsp;&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;
      {% for post in @site.posts|tagged:tag %}
        &amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;{{ post.date | date: '%b %e, %Y' }}&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;&amp;lt;a href=&quot;{{ post.url }}&quot;&amp;gt;{{ post.title }}&amp;lt;/a&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;
      {% endfor %}
    {% endfor %}
  &amp;lt;/table&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;Similarly, I had some ugly code in my regular &lt;a href=&quot;/archive/&quot;&gt;archive&lt;/a&gt; page to group by year and put headings in:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% for post in site.posts %}
  {% unless post.next %}
    &amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;{{ post.date | date: '%Y' }}&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;&amp;amp;nbsp;&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;
  {% else %}
    {% capture year %}{{ post.date | date: '%Y' }}{% endcapture %}
    {% capture nyear %}{{ post.next.date | date: '%Y' }}{% endcapture %}
    {% if year != nyear %}
      &amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;{{ post.date | date: '%Y' }}&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;&amp;amp;nbsp;&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;
    {% endif %}
  {% endunless %}

  ...
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, a few extra liquid filters later, it looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{% for post in site.posts %}
  {% if post.next|last_of_year? %}
    &amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;{{ post.date | date: '%Y' }}&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;&amp;amp;nbsp;&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;
  {% endif %}

  ...
{% endfor %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to get easy extensions in your own project, rather than maintaining Yet Another Jekyll Fork, please vote up &lt;a href=&quot;http://github.com/mojombo/jekyll/issues#issue/100&quot;&gt;my merge request&lt;/a&gt; on github.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;As a side note, blogging about liquid is a pain. The least pain I've found so far is to use liquid to output the leading open brace for all tags. Looks like garbage in my text editor, but it gets the job done:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{'{'}}{ post.title }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Blogging about blogging about liquid (as above) I leave as an exercise to the reader.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Hoptoad v2 in Merb</title>
    <link href="http://blog.tracefunc.com/2009/12/01/hoptoad-v2-in-merb/" />
    <id>tag:blog.tracefunc.com,2009-12-01T00:00:00-05:00:1259720641</id>
    <updated>2009-12-01T21:24:01-05:00</updated>
    <content type="html">&lt;p&gt;&lt;a href=&quot;http://hoptoadapp.com&quot;&gt;Hoptoad&lt;/a&gt; has been bugging us for a week or two now to upgrade to v2 of its API, so we did that this week for our project at work. Except we're running Merb, not Rails.&lt;/p&gt;

&lt;p&gt;Previously, we've been using Atmos' &lt;a href=&quot;http://github.com/atmos/merb_hoptoad_notifier&quot;&gt;merb_hoptoad plugin&lt;/a&gt;, but it looks like it's been abandoned now in favor of a rack handler, and we needed to hack it a bit to support running multiple sites (with different API keys) off our single codebase. I'm always happy throwing code away, though, so I thought I'd try using the official &lt;a href=&quot;http://github.com/thoughtbot/hoptoad_notifier&quot;&gt;Hoptoad Notifier plugin&lt;/a&gt; and see how hard it is to get working. It wasn't.&lt;/p&gt;

&lt;p&gt;First, you probably want to make a gem of the plugin. &lt;a href=&quot;http://github.com/thoughtbot/hoptoad_notifier&quot;&gt;I forked it&lt;/a&gt; a few days back, and just added a jeweller task to create the gem locally. Install in the local gems directory (or system-wide in production if you want to do it the hard way) and add it as a dependency.&lt;/p&gt;

&lt;p&gt;Then, to actually use it, just add the following in the right places:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# init.rb, in Merb::Bootloader.after_app_loads

HoptoadNotifier.configure do |config|
  config.api_key = '...'
  config.environment_name = Merb.env
  config.project_root = Merb.root
  # See http://github.com/thoughtbot/hoptoad_notifier/ README.rdoc
  # for other config settings. You probably want to think about
  # params_filters and maybe ignore.
end

# application.rb, if you want available manually.
# If you just want it for completely unexpected errors you can stick it in
# exceptions.rb instead

def notify_hoptoad(error=nil)
  error ||= request.exceptions.first

  data = {
    :controller       =&amp;gt; params[:controller],
    :action           =&amp;gt; params[:action],
    :url              =&amp;gt; &quot;#{request.protocol}://#{request.host}#{request.uri}&quot;,
    # Looks like hoptoad is filtering these itself, we don't need to worry about it
    # other than configuring what needs to be filtered
    :parameters       =&amp;gt; params.to_hash,
    :session_data     =&amp;gt; session.to_hash,
    :cgi_data         =&amp;gt; request.env.to_hash,
    :environment_vars =&amp;gt; ENV.to_hash.merge(:RAILS_ENV =&amp;gt; Merb.env)
  }

  HoptoadNotifier.notify(error, data)
end

# exceptions.rb, override default error handlers to submit to hoptoad

def internal_server_error
  notify_hoptoad
  render
end

def standard_error
  notify_hoptoad
  render
end    

# other spots you handle exceptions inline, just pass in the exception

begin
 ...
rescue =&amp;gt; e
  notify_hoptoad(e)
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It's not exactly as magical as the Rails plugin's auto-including, but it looks like it's getting the job done for us.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Enter Jekyll</title>
    <link href="http://blog.tracefunc.com/2009/11/30/enter-jekyll/" />
    <id>tag:blog.tracefunc.com,2009-11-30T00:00:00-05:00:1259719311</id>
    <updated>2009-12-01T21:01:51-05:00</updated>
    <content type="html">&lt;p&gt;So I've gone and switched up blogging platforms again. This time, it's &lt;a href=&quot;http://github.com/mojombo/jekyll&quot;&gt;Jekyll&lt;/a&gt;. It's not that I had any problems with &lt;a href=&quot;http://github.com/TwP/webby/&quot;&gt;webby&lt;/a&gt;, just thought I'd try it out. After spending a few hours porting things over (mostly layout and helpers, my posts are already in &lt;a href=&quot;http://daringfireball.net/projects/markdown/&quot;&gt;markdown&lt;/a&gt;) I think I'm going to stick with it.&lt;/p&gt;

&lt;p&gt;Being blog-aware is looking like a huge win - if I'm ok with my posts just being recorded by date, rather than date+time, there's a lot less overhead that needs to get done to push a new post up. I have smaller YAML preambles, and the only custom code I'm maintaining is some custom Liquid filters. With less time being spent worrying about the blog software, I might be more successful at the whole blog-writing bit. Maybe.&lt;/p&gt;
</content>
  </entry>
  
</feed>
